#!/bin/sh

readonly CONFIG_LOCATION=/usr/local/etc/ello-jail
[ -r $CONFIG_LOCATION ] && . $CONFIG_LOCATION

# Set defaults
: ${jails_dir:="/storage/jails"}
: ${templates_dir:="$jails_dir/templates"}



err() {
    echo "Error: " $@ 1>&2
    exit 1
}

warn() {
    echo "Warning: " $@ 1>&2
}

dir_for_jail() {
    [ ! $# = 1 ] && err "dir_for_jail expects one argument"
    echo $jails_dir/$1
}

dir_for_template() {
    [ ! $# = 1 ] && err "dir_for_template expects one argument"
    echo $templates_dir/$1
}


download() {
    local target=${1##*/}
    local destdir=$2
    local staging_area=${3%/}


    local outfile=$staging_area/$target
    if [ ! -r "$outfile" ]; then
        fetch $1 -o $outfile
    fi

    cp $outfile $destdir
}

# is_valid_label returns successfully if its first argument contains
# only English letters, hyphens and decimal digits.
is_valid_label() {
    local label=$1
    [ ${#label} -gt 0 ] && [ ${#label} -lt 64 ] && \
        echo $label | grep -qE '^[a-zA-Z0-9\-]+$'
}

# is_valid_hostname returns successfully if it is given a number (minimum 1) of
# hostnames that are valid FQDN's. The function will return unsuccessfully if it
# encounters an invalid FQDN, in which case its exit code equals the index of
# the first invalid hostname
is_valid_hostname() {
    [ $# -lt 1 ] && err "is_valid_hostname ($LINENO) expects at least \
        one argument"
    local hname=""
    local n=1
    for hname; do
        # Hostnames may not contain double dots
        case "$hname" in *..*) return $n;; esac
        [ ${#hname} -lt 256 ] || return $n
        for label in $(echo $hname | sed -E 's/\./ /g'); do
            is_valid_label $label || return $n
        done
        n=$(($n+1))
    done
    return 0
}

# is_valid_jailname returns successfully if its first argument does not contain
# dots, spaces and forward slashes
is_valid_jailname() {
    echo $1 | grep -qv '[\. /]'
}

# hostname_to_jailname translates a hostname into a jailname by replacing any
# dots by underscores.
hostname_to_jailname() {
    echo $1 | sed -E 's/\.+/_/g'
}

# is_template returns successfully if its first argument is a directory inside
# the templates directory
is_template() {
    [ -d "$templates_dir/$1" ]
}

# A space-separated list of directories that belong to the read only part of the
# base jail
readonly READ_ONLY_DIRS="./COPYRIGHT \
                         ./bin/* \
                         ./boot/* \
                         ./lib/* \
                         ./libexec/* \
                         ./rescue/* \
                         ./sbin/* \
                         ./sys/* \
                         ./usr/bin/* \
                         ./usr/games/* \
                         ./usr/include/* \
                         ./usr/lib/* \
                         ./usr/lib32/* \
                         ./usr/libdata/* \
                         ./usr/libexec/* \
                         ./usr/sbin/* \
                         ./usr/share/* \
                         ./usr/src/*"

extract() {
    [ "$#" -lt 3 ] && err "extract (${LINENO}): expecting 3 arguments"
    local archive=$1
    local destdir=$2
    local part=$3
    local option=""
    
    case $part in 
        rw)
            option=exclude;;
        ro)
            option=include;;
        *)
            err "extract (${LINENO}): third argument must be 'ro' or 'rw'";;
    esac

    inclusion_pattern=`echo $READ_ONLY_DIRS | awk '{
        for (i = 1; i <= NF; i++)
            printf "--'$option'=%s ", $i }'`

    tar -xf $archive $inclusion_pattern -C $destdir/base-$part
}

extract_rw() {
    extract $1 $2 rw
}

extract_ro() {
    extract $1 $2 ro
}


chflag_and_rm() {
    [ -d $1 ] || return 0 
    chflags -R noschg $1 &&
        rm -rf $1 > /dev/null 2>&1
}

clone() {
    local from=$1
    local what=$2
    local to=$3
    shift 3
    tar $@ -f - -C $from -c $what | tar -xf - -p -C $to
}

clone_from_base() {
    [ "$1" = "ro" ] || [ "$1" = "rw" ] ||
        err "clone_from_base ($LINENO): first argument must be ro or rw"
    local part=$1

    local from_dir=$jails_dir/base-$part
    local what=$2
    local to_dir=$3

    shift 3

    clone $from_dir $what $to_dir $@
}

clone_from_base_rw() {
    clone_from_base rw $@
}

clone_from_base_ro() {
    clone_from_base ro $@
}

# Merges the contents of a template into a jail
# $1 should contain the jail name
# $2 is an optional template name, if omitted 'default' is used
merge_template() {
    [ $# -lt 1 ] && err "merge_template requires at least one argument"

    local jail_name=$1
    local template_name=${2:-default}

    clone $(dir_for_template $template_name) . $(dir_for_jail $jail_name)
}

create_template() {
    local template_name=$1
    local t_root=$(dir_for_template $template_name)

    cleanup_and_err() {
        rm -rf $t_root > /dev/null 2>&1
        err $@
    }

    [ -d "$t_root" ] && \
        cleanup_and_err "create_template ($LINENO): Cannot create template \"${template_name}\", $t_root exists"

    mkdir -p $t_root || \
        cleanup_and_err "create_template ($LINENO): Could not create template directory $t_root"

    clone_from_base_rw "etc" $t_root -n || \
        cleanup_and_err "create_template ($LINENO): Could not create etc directory"
    clone "/" "etc/localtime" "$t_root" || \
        warn "create_template ($LINENO): Could not copy /etc/localtime to template. \
            Remember to set the correct timezone manually."
    clone_from_base_rw "etc/master.passwd" $t_root && \
        sed -E 's/^(root|toor):[^:]*:/\1:*:/g' $t_root/etc/master.passwd > $t_root/etc/master.passwd || \
        warn "create_template ($LINENO): Could not disable root password based logins."
}


create_jail() {

    local jail_name=$1
    is_valid_jailname $1 || err "$jail_name is not a valid jailname."

    local jail_template=${2:-'default'}
    is_template $jail_template || err "Template $jail_template does not exist."

    local dest_dir=$(dir_for_jail $jail_name)
    local base_dir=""
    local target=""
    local ro_dir=""
    
    cleanup_and_err() {
        rm -rf $dest_dir > /dev/null 2>&1
        err $@
    }

    [ -d "$dest_dir" ] && \
        err "create_jail ($LINENO): Cannot create a jail named \"${jail_name}\", $dest_dir exists"


    mkdir -p $dest_dir/ro
    # Ensure that usr in our new jail has the same permissions as usr in base-ro
    # The -n option forces tar to operate non-recursively, i.e. to only copy the
    # usr directory, not its contents
    clone_from_base_ro usr $dest_dir -n || \
        err "create_jail ($LINENO): Error while cloning the usr \
            directory."
    
    for ro_dir in $READ_ONLY_DIRS; do
        target=${ro_dir#./}
        target=${target%'/*'}
        ln -s /ro/$target $dest_dir/$target
    done

    clone_from_base_rw . $dest_dir || \
        cleanup_and_err "create_jail ($LINENO): Error while cloning \
            writable filesystem."

    # Finally merge template
    merge_template $jail_name $jail_template

    # write config
    cat >> /etc/jail.conf <<EOF
$jail_name {
    host.hostname="$jail_name";
    mount="$jails_dir/base-ro $dest_dir/ro nullfs ro 0 0";
    ip4.addr="10.0.2.100";
    exec.start="/bin/sh /etc/rc";
    exec.stop="/bin/sh /etc/rc.shutdown";
    mount.devfs;
    exec.clean;
    path="$dest_dir";
}
EOF
}

# Prepares the system for running jails,
# $1: directory to which the jail skeleton is installed
# $2: release of the jail
# $3: mirror
prepare() {
    local destdir=${1:-/storage/jails}
    local release=${2:-$(uname -r)}
    local mirror=${3:-"http://ftp.nl.freebsd.org/os/FreeBSD/releases/$(uname -m)/${release}"}
    local files="base.txz"
    local tmp_dir=""

    cleanup() {
        [ -d "$tmp_dir" ] && rm -rf $tmp_dir > /dev/null 2>&1
    }

    cleanup_and_err() {
        cleanup
        for i in rw ro; do
            j="$destdir/base-$i"
            [ -d "$j" ] && chflag_and_rm $j
        done
        err $@
    }

    for checkdir in $destdir/base-rw $destdir/base-ro; do
        [ -d "$checkdir" ] && \
            [ -n "$(ls -I $checkdir)" ] && \
            err "$checkdir already exists"
    done
    
    for checkdir in $destdir/base-rw $destdir/base-ro; do
        mkdir -p $checkdir || err "Error while creating $checkdir" 1
    done

    echo -n "Downloading distribution archives... "
    tmp_dir=$(mktemp -d)
    for file in $files; do
        tmp_file="${tmp_dir}/${file}"
        download "${mirror}/${file}" $tmp_file /home/jeroen || \
            cleanup_and_err "Error while fetching ${mirror}/${file}.txz" 1
    done
    echo "done."

    echo -n "Extracting base jail... " 
    for file in $files; do
        for part in ro rw; do
            extract ${tmp_dir}/${file} $destdir $part || \
                cleanup_and_err "Error while extracting ${tmp_dir}/${file}" 1
        done
    done
    echo "done."

    create_template default $1 

    cleanup
}


upgrade() {
    local jails_dir=/storage/jails
    local log_file=/var/log/ello-jail-upgrade
    local target=""
    local cycles=0

    cleanup() {
    }

    cleanup_and_err() {
        err $@
    }

    for i in ro rw; do
        [ -d "${jails_dir}/base-${i}" ] || \
            cleanup_and_err "upgrade ($LINENO): $jails_dir/base-$i not found. Did you configure ello-jail?" 1
    done

    : > $log_file
    echo -n 'Updating base...'
    for i in ro rw; do
        target=$jails_dir/base-$i
        echo -n '.'
        echo 'y' | PAGER=cat freebsd-update upgrade -b $target -r 10.1-RC4 > $log_file 2>&1 || \
            cleanup_and_err "upgrade ($LINENO): Error while fetching upgrade" 1

        cycles=0
        while [ $? -eq 0 ]; do
            cycles=$(($cycles+1))
            echo -n '.'
            PAGER=cat freebsd-update install -b $target > $log_file 2>&1
        done
    done
    echo 'done'

    if [ $cycles -gt 1 ]; then # We need to update the individual jails as well for changes in configuration files
    fi

    cleanup
}

usage() {
    err "ello-jail: prepare"
    exit
}

if [ "$#" -lt 1 ]; then
    usage
fi

command=${1:-usage}
shift
case $command in
    "prepare")
        prepare $@
        ;;
    "extract")
        extract $@
        ;;
    "create")
        create_jail $@
        ;;
    "create-template")
        create_template $@
        ;;
    "upgrade")
        upgrade
        ;;
    "usage")
        usage
        ;;
    *)
        err "Unknown function \"${command}\""
        usage
        ;;
esac
